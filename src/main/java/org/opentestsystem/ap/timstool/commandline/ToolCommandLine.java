package org.opentestsystem.ap.timstool.commandline;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.ParseException;
import org.opentestsystem.ap.timstool.ToolProperties;
import org.opentestsystem.ap.timstool.exception.UsageException;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.function.Consumer;

/**
 * The tool interface for communicating with the user.  It wraps a {@link CommandLine} instance.  The user provides the
 * command and option information.
 * <p>
 * Input/output to the console is handled by this class.  Command classes provide whatever IO functionality they need
 * for interacting with the user.  Those classes should utilize this class for the low level console interaction.
 * <p>
 * If this class is missing methods, for example methods to capture user input, then those methods should be added.
 */
@Slf4j
@Getter
public class ToolCommandLine {

    private static final String EMPTY = "";

    private static final String SPACE = " ";

    private static final PrintStream CONSOLE = System.out;

    private final ToolProperties toolProperties;

    private final ToolCommandLineCommands commandLineCommands;

    private final ToolCommandLineOptions commandLineOptions;

    private final CommandLine commandLine;

    private final HelpFormatter helpFormatter;

    private final String usageText;

    public ToolCommandLine(ToolProperties toolProperties, String... args) {
        this.toolProperties = toolProperties;

        this.usageText = String.format("usage: %s [option...] command", toolProperties.getAppScriptName());

        this.commandLineCommands = new ToolCommandLineCommands();

        this.commandLineOptions = new ToolCommandLineOptions();

        this.helpFormatter = new HelpFormatter();
        CommandLineParser parser = new DefaultParser();
        try {
            this.commandLine = parser.parse(this.commandLineOptions.getOptions(), args);
        } catch (ParseException e) {
            String error = "Unexpected exception: " + e.getMessage();
            log.error(error, e);
            throw new RuntimeException(error);
        }
    }

    // ------------------------------------------------------------------------

    public String getCommandName() {
        String command = this.commandLine.getArgList().get(0);
        if (commandLineCommands.isNotValid(command)) {
            throw new UsageException("Command '" + command + "' is not valid");
        }
        return command;
    }

    public String getInputFile() {
        return this.getOptionValue(this.commandLineOptions.getInputFile());
    }

    public Resource getInputFileAsResource() {
        Path inputFile = Paths.get(this.getInputFile());
        return new FileSystemResource(inputFile.toFile());
    }

    public String getOutputFile() {
        return this.getOptionValue(this.commandLineOptions.getOutputFile());
    }

    public void writeToOutputFile(String content) {
        String outputFileName = this.getOutputFile();
        Path outputFilePath = Paths.get(outputFileName);
        try {
            Files.write(outputFilePath, content.getBytes());
        } catch (IOException e) {
            CONSOLE.println("Failed to write content to " + outputFilePath.toString());
            CONSOLE.println("--- BEGIN CONTENT ---");
            CONSOLE.println();
            CONSOLE.println(content);
            CONSOLE.println();
            CONSOLE.println("--- END CONTENT ---");
        }
    }

    public String getAuthToken() {
        return this.getOptionValue(this.commandLineOptions.getAuthToken());
    }

    private String getOptionValue(Option option) {
        return this.commandLine.getOptionValue(option.getOpt());
    }

    // ------------------------------------------------------------------------

    /**
     * Common usage is validation prior to knowing the command being executed.  Once the command being executed is known
     * then specific validation are run for it.
     */
    public void validateCommonUsage() {
        if (this.commandLine.getArgList().size() > 1) {
            throw new UsageException("More than one command was given.  Only one command is allowed.");
        }
    }

    public boolean hasShowHelp() {
        return this.commandLine.hasOption(this.commandLineOptions.getHelp().getOpt());
    }

    public boolean hasShowCommands() {
        return this.hasOption(this.commandLineOptions.getCommands());
    }

    public boolean hasInputFile() {
        return this.hasOption(this.commandLineOptions.getInputFile());
    }

    public boolean hasOutputFile() {
        return this.hasOption(this.commandLineOptions.getOutputFile());
    }

    public boolean hasAuthToken() {
        return this.hasOption(this.commandLineOptions.getAuthToken());
    }

    public boolean isCommandMissing() {
        return this.commandLine.getArgList().isEmpty();
    }

    private boolean hasOption(Option option) {
        return this.commandLine.hasOption(option.getOpt());
    }

    // ------------------------------------------------------------------------

    public void printMessage(String message) {
        CONSOLE.println(message);
    }

    public void printCommandError(String message) {
        CONSOLE.println(message);
    }

    public void printUsageError(String message) {
        CONSOLE.println(message);
        CONSOLE.println();
        this.printHelp();
    }

    public void printCommands() {
        Consumer<String> printCommandName = cmd -> CONSOLE.println(SPACE + cmd);
        CONSOLE.println("commands: ");
        this.commandLineCommands.getCommands().keySet().stream().forEach(printCommandName);
    }

    public void printHelp() {
        this.helpFormatter.printHelp(this.usageText, this.commandLineOptions.getOptions());
    }

}
