package org.opentestsystem.ap.timstool.commandline;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.ParseException;
import org.opentestsystem.ap.timstool.ToolProperties;
import org.opentestsystem.ap.timstool.command.Command;
import org.opentestsystem.ap.timstool.command.CommandEnum;
import org.opentestsystem.ap.timstool.exception.UsageException;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

/**
 * The tool interface for communicating with the user.  It wraps a {@link CommandLine} instance.  The user provides the
 * command and option information.
 * <p>
 * Input/output to the console is handled by this class.  Command classes provide whatever IO functionality they need
 * for interacting with the user.  Those classes should utilize this class for the low level console interaction.
 * <p>
 * If this class is missing methods, for example methods to capture user input, then those methods should be added.
 */
@Slf4j
@Getter
public class ToolCommandLine {

    private static final String EMPTY = "";

    private static final String SPACE = " ";

    private static final PrintStream CONSOLE = System.out;

    private final ToolProperties toolProperties;

    private final ToolCommands toolCommands;

    private final ToolOptions toolOptions;

    private final CommandLineParser parser;

    private final HelpFormatter helpFormatter;

    private CommandLine commandLine;

    public ToolCommandLine(ToolProperties toolProperties, ToolCommands toolCommands) {
        this(
            toolProperties,
            toolCommands,
            new ToolOptions(),
            new DefaultParser(),
            new HelpFormatter()
        );
    }

    public ToolCommandLine(ToolProperties toolProperties,
                           ToolCommands toolCommands,
                           ToolOptions toolOptions,
                           CommandLineParser parser,
                           HelpFormatter helpFormatter) {
        this.toolProperties = toolProperties;
        this.toolCommands = toolCommands;
        this.toolOptions = toolOptions;
        this.parser = parser;
        this.helpFormatter = helpFormatter;
    }

    public void applyArgs(String... args) {
        try {
            this.commandLine = parser.parse(this.toolOptions.getOptions(), args);
        } catch (ParseException e) {
            throw new UsageException(e.getMessage());
        }
    }

    public String getCommandName() {
        this.validateCommand();
        return this.commandName();
    }

    public Command getCommandInstance() {
        this.validateCommand();
        return this.toolCommands.getCommandInstance(this.commandName());
    }

    public String getInputFile() {
        return this.getOptionValue(this.toolOptions.getInputFile());
    }

    public Resource getInputFileAsResource() {
        Path inputFile = Paths.get(this.getInputFile());
        return new FileSystemResource(inputFile.toFile());
    }

    public List<String> getItemIds() {
        String itemIdStr = commandLine.getOptionValue("d");
        return itemIdStr != null
            ? Arrays.asList(itemIdStr.replaceAll("\\s", "").split(",")) //remove whitespace
            : new ArrayList<>();
    }

    public Long getContentPackageId() {
        return commandLine.getArgs().length < 2 ? null : Long.valueOf(commandLine.getArgs()[1]);
    }

    public String getOutputFile() {
        return this.getOptionValue(this.toolOptions.getOutputFile());
    }

    public Path writeToOutputFile(String content, OpenOption... options) {
        String outputFileName = this.getOutputFile();
        Path outputFilePath = Paths.get(outputFileName);
        try {
            Files.write(outputFilePath, content.getBytes(), options);
            return outputFilePath;
        } catch (IOException e) {
            CONSOLE.println("Failed to write content to " + outputFilePath.toString());
            CONSOLE.println("--- BEGIN CONTENT ---");
            CONSOLE.println();
            CONSOLE.println(content);
            CONSOLE.println();
            CONSOLE.println("--- END CONTENT ---");
            throw new RuntimeException("Error writing to output file: " + e.getMessage(), e);
        }
    }

    public Path writeToOutputFile(byte[] content, OpenOption... options) {
        String outputFileName = this.getOutputFile();
        Path outputFilePath = Paths.get(outputFileName);
        try {
            Files.write(outputFilePath, content, options);
            return outputFilePath;
        } catch (IOException e) {
            CONSOLE.println("Failed to write content to " + outputFilePath.toString());
            CONSOLE.println("--- BEGIN CONTENT ---");
            CONSOLE.println();
            CONSOLE.println(content);
            CONSOLE.println();
            CONSOLE.println("--- END CONTENT ---");
            throw new RuntimeException("Error writing to output file: " + e.getMessage(), e);
        }
    }

    private String getOptionValue(Option option) {
        return this.commandLine.getOptionValue(option.getOpt());
    }

    /**
     * Validates the command given on the command line is correct.
     */
    public void validateCommand() {
        if (this.isCommandMissing()) {
            throw new UsageException("No command was given, one command is required.");
        }

        String command = this.commandName();

        if (this.commandLine.getArgList().size() > 1 && command.equals(CommandEnum.CreateTestPackage.getText())) {
            throw new UsageException("More than one command was given, only one command is allowed.");
        }

        if (this.toolCommands.isNotValid(command)) {
            throw new UsageException(String.format("Command '%s' is not valid", command));
        }
    }

    public boolean hasShowHelp() {
        return this.commandLine.hasOption(this.toolOptions.getHelp().getOpt());
    }

    public boolean hasShowCommands() {
        return this.hasOption(this.toolOptions.getCommands());
    }

    public boolean hasInputFile() {
        return this.hasOption(this.toolOptions.getInputFile());
    }

    public boolean hasOutputFile() {
        return this.hasOption(this.toolOptions.getOutputFile());
    }

    public boolean isCommandMissing() {
        return this.commandLine.getArgList().isEmpty();
    }

    private boolean hasOption(Option option) {
        return this.commandLine.hasOption(option.getOpt());
    }

    public void printMessage(String message) {
        CONSOLE.println(message);
    }

    public void printMessage(String message, Object... args) {
        CONSOLE.println(String.format(message, args));
    }

    public void printCommandError(String message) {
        CONSOLE.println(message);
    }

    public void printUsageError(String message) {
        CONSOLE.println(message);
        CONSOLE.println();
        this.printHelp();
    }

    public void printCommands() {
        Consumer<String> printCommandName = cmd -> CONSOLE.println(SPACE + cmd);
        CONSOLE.println("commands: ");
        this.toolCommands.getCommands().stream().forEach(printCommandName);
    }

    public void printHelp() {
        this.helpFormatter.printHelp(this.usageText(), this.toolOptions.getOptions());
    }

    /**
     * Quick retrieval of the command name from the list.
     *
     * @return The name of the command the user is executing.
     */
    private String commandName() {
        return this.commandLine.getArgList().get(0);
    }

    private String usageText() {
        return String.format("usage: %s [option...] command", toolProperties.getAppScriptName());
    }
}
