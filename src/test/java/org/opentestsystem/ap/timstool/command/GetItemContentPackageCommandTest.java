package org.opentestsystem.ap.timstool.command;

import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.timstool.ToolProperties;
import org.opentestsystem.ap.timstool.commandline.ToolCommandLine;
import org.opentestsystem.ap.timstool.commandline.ToolCommands;
import org.opentestsystem.ap.timstool.exception.UsageException;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.oauth2.client.OAuth2RestOperations;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class GetItemContentPackageCommandTest {
    static final String COMMAND_NAME = CommandEnum.GetItemContentCommand.getText();

    static final String OUTPUT_FILE_NAME = "output.zip";

    static final Path OUT_PUT_FILE_PATH = Paths.get(OUTPUT_FILE_NAME);

    ToolProperties toolProperties;

    ToolCommandLine toolCommandLine;

    GetItemContentPackageCommand command;

    @Mock
    ToolCommands mockCommandLineCommands;

    @Mock
    OAuth2RestOperations mockRestTemplate;

    @Mock
    ResponseEntity mockResponseEntity;

    ArgumentCaptor<HttpEntity> argumentCaptor;

    @Before
    public void setUp() throws IOException {
        toolProperties = new ToolProperties();
        toolProperties.setAppScriptName("tims");
        toolProperties.setApiGatewayUrl("https:/api-gateway");
        toolProperties.setTranslationContentPackageEndpoint("translation/content-packages");

        command = new GetItemContentPackageCommand(toolProperties, mockRestTemplate);

        argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);

        toolCommandLine = new ToolCommandLine(toolProperties, mockCommandLineCommands);

        deleteOutputFile();
    }

    @After
    public void tearDown() throws IOException {
        deleteOutputFile();
    }

    void deleteOutputFile() throws IOException {
        if (Files.exists(OUT_PUT_FILE_PATH)) {
            Files.delete(OUT_PUT_FILE_PATH);
        }
    }

    @Test
    public void testExecuteSuccess() {
        final long contentPackageId = 1;
        when(mockResponseEntity.getBody()).thenReturn("SUCCESS".getBytes());
        when(mockResponseEntity.getStatusCode()).thenReturn(HttpStatus.OK);
        when(
            mockRestTemplate.exchange(
                eq(String.format("%s/%s/%s/content", toolProperties.getApiGatewayUrl(),
                    toolProperties.getTranslationContentPackageEndpoint(), contentPackageId)),
                eq(HttpMethod.GET),
                argumentCaptor.capture(),
                eq(byte[].class)))
            .thenReturn(mockResponseEntity);

        toolCommandLine.applyArgs(
            COMMAND_NAME,
            "-o", "output.zip",
            String.valueOf(contentPackageId));

        command.execute(toolCommandLine);

        assertThat(Files.exists(OUT_PUT_FILE_PATH)).isTrue();
    }

    @Test
    public void testWhenNoOutputFileOptionGiven() {
        toolCommandLine.applyArgs(
            COMMAND_NAME,
            "1");
        assertCommandValidation(toolCommandLine,
            "Command get-saaif-content-package-archive requires an output file be specified.");
    }

    @Test
    public void testWhenNoContentPackageArgGiven() {
        toolCommandLine.applyArgs(
            COMMAND_NAME,
            "-o", "output.zip");
        assertCommandValidation(toolCommandLine,
            "Command get-saaif-content-package-archive requires a content package id be specified.");
    }

    void assertCommandValidation(ToolCommandLine toolCommandLine, String expectedErrorMessage) {
        try {
            command.execute(toolCommandLine);
            Assert.fail("Expected UsageException");
        } catch (UsageException e) {
            assertThat(e.getMessage()).isEqualTo(expectedErrorMessage);
        }
    }
}
