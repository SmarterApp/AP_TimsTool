package org.opentestsystem.ap.timstool.commandline;

import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.timstool.ToolProperties;
import org.opentestsystem.ap.timstool.command.Command;
import org.opentestsystem.ap.timstool.command.CommandEnum;
import org.opentestsystem.ap.timstool.command.CreateTestPackageCommand;
import org.opentestsystem.ap.timstool.exception.UsageException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;

import static java.nio.file.StandardOpenOption.CREATE_NEW;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ToolCommandLineTest {

    static final String COMMAND_NAME = CommandEnum.CreateTestPackage.getText();

    static final String OUTPUT_FILE_NAME = "output.xml";

    static final Path OUT_PUT_FILE_PATH = Paths.get(OUTPUT_FILE_NAME);

    @Mock
    CommandLineParser commandLineParser;

    @Mock
    CreateTestPackageCommand commandInstance;

    ToolProperties toolProperties;

    ToolCommandLine toolCommandLine;

    ToolCommands toolCommands;

    Map<CommandEnum, Command> commandMap = new HashMap<>();

    ParseException parseException;

    @Before
    public void setUp() throws IOException {
        toolProperties = new ToolProperties();
        toolProperties.setAppScriptName("tims");
        toolProperties.setApiGatewayUrl("https:/api-gateway");
        toolProperties.setCreateTestManagementEndpoint("/tms/create/test/package");

        parseException = new ParseException("this is a parse exception");

        commandMap.put(CommandEnum.CreateTestPackage, commandInstance);
        toolCommands = new ToolCommands(commandMap);

        toolCommandLine = new ToolCommandLine(toolProperties, toolCommands);

        deleteOutputFile();
    }

    @After
    public void tearDown() throws IOException {
        deleteOutputFile();
    }

    void deleteOutputFile() throws IOException {
        if (Files.exists(OUT_PUT_FILE_PATH)) {
            Files.delete(OUT_PUT_FILE_PATH);
        }
    }

    @Test
    public void testGetters() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-o", OUTPUT_FILE_NAME);
        assertThat(toolCommandLine.getToolProperties()).isNotNull();
        assertThat(toolCommandLine.getToolCommands()).isNotNull();
        assertThat(toolCommandLine.getToolOptions()).isNotNull();
        assertThat(toolCommandLine.getToolOptions()).isNotNull();
        assertThat(toolCommandLine.getCommandLine()).isNotNull();
        assertThat(toolCommandLine.getHelpFormatter()).isNotNull();
    }

    @Test
    public void testWriteToOutputFile() {
        assertThat(Files.exists(OUT_PUT_FILE_PATH)).isFalse();
        toolCommandLine.applyArgs(COMMAND_NAME, "-o", OUTPUT_FILE_NAME);
        toolCommandLine.writeToOutputFile("<item></item>");
        assertThat(Files.exists(OUT_PUT_FILE_PATH)).isTrue();
        try {
            toolCommandLine.writeToOutputFile("<stim></stim>", CREATE_NEW);
            Assert.fail("Expected RuntimeException to be thrown");
        } catch (RuntimeException e) {
            assertThat(e.getMessage()).isEqualTo("Error writing to output file: " + OUTPUT_FILE_NAME);
        }
    }

    @Test
    public void testConstructorWhenParseExceptionThrown() throws ParseException {
        when(commandLineParser.parse(any(Options.class), any(String[].class))).thenThrow(parseException);
        try {
            toolCommandLine = new ToolCommandLine(
                toolProperties,
                toolCommands,
                new ToolOptions(),
                commandLineParser,
                new HelpFormatter());


            toolCommandLine.applyArgs(COMMAND_NAME, "-t", "auth123");
        } catch (UsageException e) {
            assertThat(e.getMessage()).isEqualTo("this is a parse exception");
        }
    }

    @Test
    public void testGetParser() {
        CommandLineParser parser = toolCommandLine.getParser();
        assertThat(parser).isInstanceOf(DefaultParser.class);
    }

    @Test
    public void testGetCommandName() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-d", "auth123");
        assertThat(toolCommandLine.getCommandName()).isEqualTo(COMMAND_NAME);
    }

    @Test
    public void testGetCommandNameWhenItsInvalid() {
        toolCommandLine.applyArgs(COMMAND_NAME + "_invalid", "-d", "auth123");
        try {
            toolCommandLine.getCommandName();
            Assert.fail("Expected usage exception");
        } catch (UsageException e) {
            assertThat(e.getMessage()).isEqualTo("Command '" + COMMAND_NAME + "_invalid' is not valid");
        }
    }

    @Test
    public void testToolCommandLineAuthOptionMissingRequiredValue() {
        try {
            toolCommandLine.applyArgs("-d");
            Assert.fail("Expected UsageException");
        } catch (UsageException e) {
            assertThat(e.getMessage()).isEqualTo("Missing argument for option: d");
        }
    }

    @Test
    public void testToolCommandLineInputOption() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-i", "input.txt");
        assertThat(toolCommandLine.hasInputFile()).isTrue();
        assertThat(toolCommandLine.getInputFile()).isEqualTo("input.txt");
        assertThat(toolCommandLine.getInputFileAsResource().getFilename()).isEqualTo("input.txt");
    }

    @Test
    public void testToolCommandLineInputOptionMissingRequiredValue() {
        try {
            toolCommandLine.applyArgs(COMMAND_NAME, "-i");
            Assert.fail("Expected UsageException");
        } catch (UsageException e) {
            assertThat(e.getMessage()).isEqualTo("Missing argument for option: i");
        }
    }

    @Test
    public void testToolCommandLineOutputOption() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-o", "output.xml");
        assertThat(toolCommandLine.hasOutputFile()).isTrue();
        assertThat(toolCommandLine.getOutputFile()).isEqualTo("output.xml");
    }

    @Test
    public void testToolCommandLineOutputOptionMissingRequiredValue() {
        try {
            toolCommandLine.applyArgs(COMMAND_NAME, "-o");
            Assert.fail("Expected UsageException");
        } catch (UsageException e) {
            assertThat(e.getMessage()).isEqualTo("Missing argument for option: o");
        }
    }

    @Test
    public void testToolCommandLineHelpOption() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-h");
        assertThat(toolCommandLine.hasShowHelp()).isTrue();
    }

    @Test
    public void testToolCommandLineCommandOption() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-c");
        assertThat(toolCommandLine.hasShowCommands()).isTrue();
    }

    @Test
    public void testIsCommandMissing() {
        toolCommandLine.applyArgs("-i", "input.txt");
        assertThat(toolCommandLine.isCommandMissing()).isTrue();
        toolCommandLine.applyArgs(COMMAND_NAME, "-i", "input.txt");
        assertThat(toolCommandLine.isCommandMissing()).isFalse();
    }

    @Test
    public void testValidateCommand() {
        // one arg is present, no exception expected
        toolCommandLine.applyArgs(COMMAND_NAME,
            "-i", "input.txt",
            "-o", "output.txt");
        toolCommandLine.validateCommand();

        // two commandMap present, expecting UsageException
        toolCommandLine.applyArgs(COMMAND_NAME, "generate-user-report",
            "-i", "input.txt",
            "-o", "output.txt");
        try {
            toolCommandLine.validateCommand();
            Assert.fail("Expected UsageException to be thrown");
        } catch (UsageException e) {
            assertThat(e.getMessage()).isEqualTo("More than one command was given, only one command is allowed.");
        }

        // no command present, expecting UsageException
        toolCommandLine.applyArgs(
            "-i", "input.txt",
            "-o", "output.txt");
        try {
            toolCommandLine.validateCommand();
            Assert.fail("Expected UsageException to be thrown");
        } catch (UsageException e) {
            assertThat(e.getMessage()).isEqualTo("No command was given, one command is required.");
        }
    }

    @Test
    public void testPrintMessage() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-h");
        toolCommandLine.printMessage("printing this message");
    }

    @Test
    public void testPrintCommands() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-h");
        toolCommandLine.printCommands();
    }

    @Test
    public void testPrintCommandError() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-h");
        toolCommandLine.printCommandError("printing this message");
    }

    @Test
    public void testPrintUsageError() {
        toolCommandLine.applyArgs(COMMAND_NAME, "-h");
        toolCommandLine.printUsageError("printing this message");
    }
}

